#!/usr/bin/env ruby
# frozen_string_literal: true

# Script to continuously enqueue random jobs for testing
# Usage: bin/enqueue [interval_seconds] [batch_size]
#
# Examples:
#   bin/enqueue              # Default: 1 job every 1 second
#   bin/enqueue 0.5          # 1 job every 0.5 seconds
#   bin/enqueue 1 3          # 3 jobs every 1 second

require_relative "../spec/dummy/config/environment"

INTERVAL = (ARGV[0] || 1).to_f
BATCH_SIZE = (ARGV[1] || 1).to_i

# Job configurations with weights (higher = more frequent)
JOBS = [
  # Sidekiq Jobs
  { klass: "SuccessJob", weight: 30, args: -> { [["Hello #{Time.now.to_i}", nil].sample] } },
  { klass: "FlakyJob", weight: 20, args: -> { [[0.5, 0.7, 0.3].sample] } },
  { klass: "DoomedJob", weight: 5, args: -> { [["bad luck", "inevitable", nil].sample] } },
  { klass: "SlowJob", weight: 10, args: -> { [[1, 2, 3].sample] } },
  { klass: "ComplexArgsJob", weight: 15, args: -> { [rand(1000..9999), { action: %w[create update delete].sample, priority: rand(1..5) }] } },
  { klass: "CriticalJob", weight: 10, args: -> { [%w[high medium low].sample] } },

  # ActiveJob Jobs
  { klass: "ActiveSuccessJob", weight: 25, args: -> { ["ActiveJob message #{Time.now.to_i}"] }, active_job: true },
  { klass: "ActiveFlakyJob", weight: 15, args: -> { [[0.5, 0.6].sample] }, active_job: true },
  { klass: "ActiveDoomedJob", weight: 3, args: -> { ["ActiveJob doom"] }, active_job: true },

  # Scheduled Jobs
  { klass: "SuccessJob", weight: 10, args: -> { ["Scheduled #{Time.now.to_i}"] }, delay: -> { rand(5..30) } },
  { klass: "ActiveSuccessJob", weight: 8, args: -> { ["Scheduled ActiveJob #{Time.now.to_i}"] }, active_job: true, delay: -> { rand(5..30) } },

  # Batch Jobs (Sidekiq Pro)
  # { klass: "BatchChildJob", weight: 5, batch: true, batch_size: -> { rand(3..5) } },
].freeze

# Build weighted list for random selection
WEIGHTED_JOBS = JOBS.flat_map { |job| [job] * job[:weight] }.freeze

puts "=" * 60
puts "Job Enqueuer Started"
puts "=" * 60
puts "Interval: #{INTERVAL}s | Batch size: #{BATCH_SIZE}"
puts "Press Ctrl+C to stop"
puts "=" * 60
puts

# Stats tracking
stats = Hash.new(0)
start_time = Time.zone.now

trap("INT") do
  puts "\n\n#{'=' * 60}"
  puts "Stopping... Final Stats:"
  puts "=" * 60
  puts "Runtime: #{(Time.zone.now - start_time).round(1)}s"
  puts "Total jobs enqueued: #{stats.values.sum}"
  stats.sort_by { |_, v| -v }.each do |klass, count|
    puts "  #{klass}: #{count}"
  end
  puts "=" * 60
  exit
end

def enqueue_batch(job_config)
  klass = job_config[:klass].constantize
  batch_size = job_config[:batch_size].call

  batch = Sidekiq::Batch.new
  batch.description = "Test batch #{Time.zone.now.to_i}"
  batch.jobs do
    batch_size.times { |i| klass.perform_async(i + 1) }
  end

  [batch.bid, batch_size]
end

# rubocop:disable Metrics/BlockLength
loop do
  BATCH_SIZE.times do
    job_config = WEIGHTED_JOBS.sample
    klass = job_config[:klass].constantize

    begin
      if job_config[:batch]
        bid, size = enqueue_batch(job_config)
        stats["Batch(#{job_config[:klass]})"] += 1
        puts "[#{Time.zone.now.strftime('%H:%M:%S')}] ðŸ“¦ Batch #{bid[0..7]}... (#{size} jobs)"
      elsif job_config[:active_job]
        args = job_config[:args].call
        delay = job_config[:delay]&.call
        if delay
          klass.set(wait: delay.seconds).perform_later(*args)
          puts "[#{Time.zone.now.strftime('%H:%M:%S')}] â° #{job_config[:klass]} in #{delay}s #{args.inspect[0..40]}"
        else
          klass.perform_later(*args)
          puts "[#{Time.zone.now.strftime('%H:%M:%S')}] âœ“ #{job_config[:klass]} #{args.inspect[0..50]}"
        end
        stats[job_config[:klass]] += 1
      else
        args = job_config[:args].call
        delay = job_config[:delay]&.call
        if delay
          klass.perform_in(delay, *args)
          puts "[#{Time.zone.now.strftime('%H:%M:%S')}] â° #{job_config[:klass]} in #{delay}s #{args.inspect[0..40]}"
        else
          klass.perform_async(*args)
          puts "[#{Time.zone.now.strftime('%H:%M:%S')}] âœ“ #{job_config[:klass]} #{args.inspect[0..50]}"
        end
        stats[job_config[:klass]] += 1
      end
    rescue StandardError => e
      puts "[#{Time.zone.now.strftime('%H:%M:%S')}] âœ— #{job_config[:klass]}: #{e.message}"
    end
  end

  sleep INTERVAL
end
# rubocop:enable Metrics/BlockLength
